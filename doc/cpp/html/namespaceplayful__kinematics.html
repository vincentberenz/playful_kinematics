<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>playful kinematics (c++ backend): playful_kinematics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">playful kinematics (c++ backend)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">playful_kinematics Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8dccdc3f309e9c9c2d0c387609e5114f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a8dccdc3f309e9c9c2d0c387609e5114f">forward_kinematics</a> (bool left, std::vector&lt; float &gt; &amp;posture, std::vector&lt; float &gt; &amp;get_position, std::vector&lt; float &gt; &amp;get_orientation)</td></tr>
<tr class="memdesc:a8dccdc3f309e9c9c2d0c387609e5114f"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs forward kinematics for the specified end effector  <a href="#a8dccdc3f309e9c9c2d0c387609e5114f">More...</a><br /></td></tr>
<tr class="separator:a8dccdc3f309e9c9c2d0c387609e5114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36da79ef68201b0f98939037b1b85e18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a36da79ef68201b0f98939037b1b85e18">forward_kinematics</a> (bool left, double *q, double *x, double *y, double *z, double *alpha, double *beta, double *gamma)</td></tr>
<tr class="separator:a36da79ef68201b0f98939037b1b85e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417a96d09f24cd47cd4a97cc4d32bd27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a417a96d09f24cd47cd4a97cc4d32bd27">ik</a> (bool left, float target_x, float target_y, float target_z, std::vector&lt; float &gt; &amp;get_posture, float &amp;get_score)</td></tr>
<tr class="memdesc:a417a96d09f24cd47cd4a97cc4d32bd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse kinematics for the specified end effector to reach (x,y,z) cartesian position.  <a href="#a417a96d09f24cd47cd4a97cc4d32bd27">More...</a><br /></td></tr>
<tr class="separator:a417a96d09f24cd47cd4a97cc4d32bd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd49eed71e2e281e3e7fc172ab16e6ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#afd49eed71e2e281e3e7fc172ab16e6ea">ik</a> (bool left, float target_x, float target_y, float target_z, float target_yaw, float target_pitch, float target_roll, std::vector&lt; float &gt; &amp;get_posture, float &amp;get_score)</td></tr>
<tr class="memdesc:afd49eed71e2e281e3e7fc172ab16e6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse kinematics for the specified end effector to reach (x,y,z) cartesian position and (yaw,pitch,roll) orientation  <a href="#afd49eed71e2e281e3e7fc172ab16e6ea">More...</a><br /></td></tr>
<tr class="separator:afd49eed71e2e281e3e7fc172ab16e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f8ba4a6c334c10e60d985fa786ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a3e4f8ba4a6c334c10e60d985fa786ac7">set_kinematics_joints</a> (std::vector&lt; float &gt; reference_ik_joints)</td></tr>
<tr class="separator:a3e4f8ba4a6c334c10e60d985fa786ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e85a35841d82b835f7b6df0fe40c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a885e85a35841d82b835f7b6df0fe40c4">set_kinematics_side</a> (bool left)</td></tr>
<tr class="separator:a885e85a35841d82b835f7b6df0fe40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5bf326820b4adb70db9b1a96549e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a0a5bf326820b4adb70db9b1a96549e01">set_kinematics_mask</a> (std::vector&lt; bool &gt; mask)</td></tr>
<tr class="separator:a0a5bf326820b4adb70db9b1a96549e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb4364129e16bf89b9a9192ef51518a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a0cb4364129e16bf89b9a9192ef51518a">set_kinematics_joint_limit</a> (int index, float min, float max)</td></tr>
<tr class="separator:a0cb4364129e16bf89b9a9192ef51518a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd218ec3194c02e7a4dae2c1233122f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#acd218ec3194c02e7a4dae2c1233122f9">set_minimization_priority</a> (std::vector&lt; int &gt; minimization_priority)</td></tr>
<tr class="separator:acd218ec3194c02e7a4dae2c1233122f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f4de6b8d8704a064d9aecc21c977ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#ab6f4de6b8d8704a064d9aecc21c977ca">get_kinematics_joints</a> (std::vector&lt; float &gt; &amp;get)</td></tr>
<tr class="separator:ab6f4de6b8d8704a064d9aecc21c977ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8404141399594c43e572d8cc2ecab51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#ae8404141399594c43e572d8cc2ecab51">get_kinematics_side</a> ()</td></tr>
<tr class="separator:ae8404141399594c43e572d8cc2ecab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8572d4ea55db5ac207c2a9bff1d20419"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a8572d4ea55db5ac207c2a9bff1d20419">get_minimization_priority</a> (int size)</td></tr>
<tr class="separator:a8572d4ea55db5ac207c2a9bff1d20419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70201e295be6e66164dfcc4f1ff141ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a70201e295be6e66164dfcc4f1ff141ba">get_kinematics_mask</a> ()</td></tr>
<tr class="separator:a70201e295be6e66164dfcc4f1ff141ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f64b2dd3bd915438d8e8338379628e"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a72f64b2dd3bd915438d8e8338379628e">get_kinematics_joint_min_limit</a> ()</td></tr>
<tr class="separator:a72f64b2dd3bd915438d8e8338379628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f9fdb92eff846301e977ad2e7d3df2"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a49f9fdb92eff846301e977ad2e7d3df2">get_kinematics_joint_max_limit</a> ()</td></tr>
<tr class="separator:a49f9fdb92eff846301e977ad2e7d3df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4732e9812763762c20fd9fa6f455ded"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#ab4732e9812763762c20fd9fa6f455ded">get_kinematics_nb_joints</a> ()</td></tr>
<tr class="separator:ab4732e9812763762c20fd9fa6f455ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d816218ad14f70b0c9a0cd073fee81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#ab7d816218ad14f70b0c9a0cd073fee81">set_target_cartesian_position</a> (float x, float y, float z, float alpha, float beta, float gamma)</td></tr>
<tr class="separator:ab7d816218ad14f70b0c9a0cd073fee81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093cbe006f18dbd16904187f585a88fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a093cbe006f18dbd16904187f585a88fc">set_configuration</a> (bool left, std::vector&lt; bool &gt; mask)</td></tr>
<tr class="separator:a093cbe006f18dbd16904187f585a88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106be8ea068c6e020a60819d8dcd93ab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a106be8ea068c6e020a60819d8dcd93ab">at_desired_cartesian_position</a> (std::vector&lt; float &gt; &amp;posture)</td></tr>
<tr class="separator:a106be8ea068c6e020a60819d8dcd93ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d2a0954f22df39d9a47939bf76c5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#aa0d2a0954f22df39d9a47939bf76c5a3">minimize</a> (std::vector&lt; float &gt; &amp;posture, std::map&lt; int, float &gt; min, std::map&lt; int, float &gt; max, float target_score, float max_step, float min_step, int max_iteration, float(*score)(std::vector&lt; float &gt; &amp;), float &amp;final_score)</td></tr>
<tr class="memdesc:aa0d2a0954f22df39d9a47939bf76c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the input posture such as minimizing the scoring function using gradient descent.  <a href="#aa0d2a0954f22df39d9a47939bf76c5a3">More...</a><br /></td></tr>
<tr class="separator:aa0d2a0954f22df39d9a47939bf76c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7191d1faf3e56c04f71ad69034ae4f09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayful__kinematics.html#a7191d1faf3e56c04f71ad69034ae4f09">minimize</a> (std::vector&lt; float &gt; &amp;posture, std::vector&lt; int &gt; minimization_priority, std::map&lt; int, float &gt; min, std::map&lt; int, float &gt; max, float target_score, float max_step, float min_step, int max_iteration, float(*score)(std::vector&lt; float &gt; &amp;), float &amp;final_score)</td></tr>
<tr class="memdesc:a7191d1faf3e56c04f71ad69034ae4f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the input posture such as minimizing the scoring function using gradient descent.  <a href="#a7191d1faf3e56c04f71ad69034ae4f09">More...</a><br /></td></tr>
<tr class="separator:a7191d1faf3e56c04f71ad69034ae4f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a106be8ea068c6e020a60819d8dcd93ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float playful_kinematics::at_desired_cartesian_position </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>posture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>score function, call set_target_cartesian_position and set_configuration first </p>

</div>
</div>
<a class="anchor" id="a8dccdc3f309e9c9c2d0c387609e5114f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>posture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>get_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>get_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs forward kinematics for the specified end effector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>left end effector if true, right end effector otherwise </td></tr>
    <tr><td class="paramname">posture</td><td>list of current joint position of the kinematic chain (as defined in the urdf and specified in the CMakeLists.txt) </td></tr>
    <tr><td class="paramname">get_position</td><td>cartesian position of the end-effector as determined by forward kinematics </td></tr>
    <tr><td class="paramname">get_orientation</td><td>yaw, pitch and roll of the end-effector as determined by forward kinematics </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36da79ef68201b0f98939037b1b85e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a49f9fdb92eff846301e977ad2e7d3df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,float&gt;&amp; playful_kinematics::get_kinematics_joint_max_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns max joint limits as last set by "set_kinematics_joint_limit" </p>

</div>
</div>
<a class="anchor" id="a72f64b2dd3bd915438d8e8338379628e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,float&gt;&amp; playful_kinematics::get_kinematics_joint_min_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns min joint limits as last set by "set_kinematics_joint_limit" </p>

</div>
</div>
<a class="anchor" id="ab6f4de6b8d8704a064d9aecc21c977ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::get_kinematics_joints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>get</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the joint position as last set by "set_reference_posture" </p>

</div>
</div>
<a class="anchor" id="a70201e295be6e66164dfcc4f1ff141ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt;&amp; playful_kinematics::get_kinematics_mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns mask as last set by "set_kinematics_mask" </p>

</div>
</div>
<a class="anchor" id="ab4732e9812763762c20fd9fa6f455ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int playful_kinematics::get_kinematics_nb_joints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the number of joints used for inverse and forward kinematics. This is based on the urdf and chain specified in the CMakeLists.txt </p>

</div>
</div>
<a class="anchor" id="ae8404141399594c43e572d8cc2ecab51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::get_kinematics_side </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the side, left (true) or right (false) as last set by "set_kinematics_side" </p>

</div>
</div>
<a class="anchor" id="a8572d4ea55db5ac207c2a9bff1d20419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; playful_kinematics::get_minimization_priority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the minimization priority as last set by "set_minimization_priority" </p>

</div>
</div>
<a class="anchor" id="a417a96d09f24cd47cd4a97cc4d32bd27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::ik </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>get_posture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>get_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs inverse kinematics for the specified end effector to reach (x,y,z) cartesian position. </p>
<p>Orientation of the end-effector is not taken into account. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>left end effector if true, right end effector otherwise </td></tr>
    <tr><td class="paramname">target_x</td><td>x position the end effector should reach </td></tr>
    <tr><td class="paramname">target_y</td><td>y position the end effector should reach </td></tr>
    <tr><td class="paramname">target_z</td><td>z position the end effector should reach </td></tr>
    <tr><td class="paramname">get_posture</td><td>joint positions corresponding of the end-effector reaching the desired cartesian position </td></tr>
    <tr><td class="paramname">get_score</td><td>how close the end effector is to the desired position. The lower the score the better. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>kinematics_config.h see how to configure the inverse kinematics job </dd>
<dd>
<a class="el" href="score__functions_8h.html">score_functions.h</a> see the scoring function used during minimization </dd>
<dd>
<a class="el" href="soma_8h.html">soma.h</a> see the minimization algorithm </dd></dl>

</div>
</div>
<a class="anchor" id="afd49eed71e2e281e3e7fc172ab16e6ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::ik </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>get_posture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>get_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs inverse kinematics for the specified end effector to reach (x,y,z) cartesian position and (yaw,pitch,roll) orientation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>left end effector if true, right end effector otherwise </td></tr>
    <tr><td class="paramname">target_x</td><td>x position the end effector should reach </td></tr>
    <tr><td class="paramname">target_y</td><td>y position the end effector should reach </td></tr>
    <tr><td class="paramname">target_z</td><td>z position the end effector should reach </td></tr>
    <tr><td class="paramname">target_yaw</td><td>yaw orientation the end effector should reach </td></tr>
    <tr><td class="paramname">target_pitch</td><td>pitch orientation the end effector should reach </td></tr>
    <tr><td class="paramname">target_roll</td><td>roll orientation the end effector should reach </td></tr>
    <tr><td class="paramname">get_posture</td><td>joint positions corresponding of the end-effector reaching the desired cartesian position </td></tr>
    <tr><td class="paramname">get_score</td><td>how close the end effector is to the desired position. The lower the score the better. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>kinematics_config.h see how to configure the inverse kinematics job </dd>
<dd>
<a class="el" href="score__functions_8h.html">score_functions.h</a> see the scoring function used during minimization </dd>
<dd>
<a class="el" href="soma_8h.html">soma.h</a> see the minimization algorithm </dd></dl>

</div>
</div>
<a class="anchor" id="aa0d2a0954f22df39d9a47939bf76c5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::minimize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>posture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, float &gt;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, float &gt;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)(std::vector&lt; float &gt; &amp;)&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>final_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the input posture such as minimizing the scoring function using gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posture</td><td>posture to be mimized </td></tr>
    <tr><td class="paramname">min</td><td>min acceptable for the minimized posture </td></tr>
    <tr><td class="paramname">max</td><td>max acceptable for the minimized posture </td></tr>
    <tr><td class="paramname">target_score</td><td>the algorithm will exit once the score below this value </td></tr>
    <tr><td class="paramname">max_step</td><td>starting 'big' step of the gradient descent </td></tr>
    <tr><td class="paramname">min_step</td><td>the step of the gradient descent will decrease to this value </td></tr>
    <tr><td class="paramname">max_iteration</td><td>the algorithm will exit early if the max number of iteration is reached </td></tr>
    <tr><td class="paramname">score</td><td>scoring function </td></tr>
    <tr><td class="paramname">final_score</td><td>score reached when the alorithm exits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7191d1faf3e56c04f71ad69034ae4f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool playful_kinematics::minimize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>posture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>minimization_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, float &gt;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, float &gt;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)(std::vector&lt; float &gt; &amp;)&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>final_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the input posture such as minimizing the scoring function using gradient descent. </p>
<p>The "minimization_priority" parameter allows to specify which dimension of the posture should be minimized first, which has an impact in which solution will be found </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posture</td><td>posture to be mimized </td></tr>
    <tr><td class="paramname">mimimization_priority,e.g</td><td>[1,2,2,2] will favor changing the value of the first dimension </td></tr>
    <tr><td class="paramname">min</td><td>min acceptable for the minimized posture </td></tr>
    <tr><td class="paramname">max</td><td>max acceptable for the minimized posture </td></tr>
    <tr><td class="paramname">target_score</td><td>the algorithm will exit once the score below this value </td></tr>
    <tr><td class="paramname">max_step</td><td>starting 'big' step of the gradient descent </td></tr>
    <tr><td class="paramname">min_step</td><td>the step of the gradient descent will decrease to this value </td></tr>
    <tr><td class="paramname">max_iteration</td><td>the algorithm will exit early if the max number of iteration is reached </td></tr>
    <tr><td class="paramname">score</td><td>scoring function </td></tr>
    <tr><td class="paramname">final_score</td><td>score reached when the alorithm exits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a093cbe006f18dbd16904187f585a88fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_configuration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set configuration: use of left arm or right arm, position mask (x,y,z,alpha,beta,gamma) e.g. [true,true,true,false,false,false] if orientation if irrelevant </p>

</div>
</div>
<a class="anchor" id="a0cb4364129e16bf89b9a9192ef51518a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_kinematics_joint_limit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the limits of the joint at the specified index </p>

</div>
</div>
<a class="anchor" id="a3e4f8ba4a6c334c10e60d985fa786ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_kinematics_joints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reference_ik_joints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set for the next inverse kinematics jobs the posture from which minimization will be performed </p>

</div>
</div>
<a class="anchor" id="a0a5bf326820b4adb70db9b1a96549e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_kinematics_mask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the mask is used to determine which dimensions in the cartesian space the inverse kinematics should take into account. for example [true,false,false,true,false,false] will only attempt to bring the end effector at the desired x position with the desired yaw. </p>

</div>
</div>
<a class="anchor" id="a885e85a35841d82b835f7b6df0fe40c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_kinematics_side </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set for the next inverse kinematics jobs the side (left or right end effector) </p>

</div>
</div>
<a class="anchor" id="acd218ec3194c02e7a4dae2c1233122f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_minimization_priority </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>minimization_priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimization toward the desired cartesian position will be done by moving first joints with higher priority (1 is higher priority that 2). thus, in case of overactuated robot, this has an impact on which solution will be found. </p>

</div>
</div>
<a class="anchor" id="ab7d816218ad14f70b0c9a0cd073fee81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playful_kinematics::set_target_cartesian_position </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the desired target cartesian position, to be used before calling at_desired_cartesian_position </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
